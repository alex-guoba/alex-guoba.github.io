<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Sentinel Code Analyze | Utopian</title><meta name="author" content="Alex guo"><meta name="copyright" content="Alex guo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="sentinel-go背景之前团队在服务治理项目过程中引入了司内稳定性相关的组件，其中也包含了流量控制、熔断降级等稳定性相关的能力，但我一直也没有时间来深挖各模块的实现细节。趁最近有空，看了下阿里开源版本的稳定性组件sentinel实现，整体感觉代码结构清晰，在并发控制、性能优化细节上也做了不少工作，于是花时间仔细阅读了下部分代码，并输出笔记一篇。 另外写文章之前发现sentinel的官方文档非常">
<meta property="og:type" content="article">
<meta property="og:title" content="Sentinel Code Analyze">
<meta property="og:url" content="https://www.goroutine.cn/2023/11/10/Sentinel-Code-Analyze/index.html">
<meta property="og:site_name" content="Utopian">
<meta property="og:description" content="sentinel-go背景之前团队在服务治理项目过程中引入了司内稳定性相关的组件，其中也包含了流量控制、熔断降级等稳定性相关的能力，但我一直也没有时间来深挖各模块的实现细节。趁最近有空，看了下阿里开源版本的稳定性组件sentinel实现，整体感觉代码结构清晰，在并发控制、性能优化细节上也做了不少工作，于是花时间仔细阅读了下部分代码，并输出笔记一篇。 另外写文章之前发现sentinel的官方文档非常">
<meta property="og:locale">
<meta property="og:image" content="https://cos.goroutine.cn/uPic/20231110-HERXa8-cyZzFk.png">
<meta property="article:published_time" content="2023-11-10T07:18:05.000Z">
<meta property="article:modified_time" content="2023-11-13T11:10:03.094Z">
<meta property="article:author" content="Alex guo">
<meta property="article:tag" content="Governance">
<meta property="article:tag" content="Microservices">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cos.goroutine.cn/uPic/20231110-HERXa8-cyZzFk.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.goroutine.cn/2023/11/10/Sentinel-Code-Analyze/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Sentinel Code Analyze',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-13 19:10:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transparency.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Utopian" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cos.goroutine.cn/uPic/20231110-HERXa8-cyZzFk.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Utopian"><span class="site-name">Utopian</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Sentinel Code Analyze</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-11-10T07:18:05.000Z" title="Created 2023-11-10 15:18:05">2023-11-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-11-13T11:10:03.094Z" title="Updated 2023-11-13 19:10:03">2023-11-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Sentinel Code Analyze"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="sentinel-go"><a href="#sentinel-go" class="headerlink" title="sentinel-go"></a>sentinel-go</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前团队在服务治理项目过程中引入了司内稳定性相关的组件，其中也包含了流量控制、熔断降级等稳定性相关的能力，但我一直也没有时间来深挖各模块的实现细节。趁最近有空，看了下阿里开源版本的稳定性组件sentinel实现，整体感觉代码结构清晰，在并发控制、性能优化细节上也做了不少工作，于是花时间仔细阅读了下部分代码，并输出笔记一篇。</p>
<p>另外写文章之前发现sentinel的官方文档非常细致，包括功能使用以及原理介绍，于是直接copy了部分，并根据最新代码做了修正。最后补充了流量控制的代码分析，其他模块原理也类似，时间有限就没有逐一阅读了。</p>
<p>Sentinel介绍：Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</p>
<span id="more"></span>

<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong><strong>流量控制</strong></strong></h3><p>任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状。</p>
<p><img src="https://sentinelguard.io/docs/zh-cn/img/sentinel-flow-overview.jpg" alt="https://sentinelguard.io/docs/zh-cn/img/sentinel-flow-overview.jpg"></p>
<p>流量控制有以下几个角度:</p>
<ul>
<li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</li>
<li>运行指标，例如 QPS、线程池、系统负载等；</li>
<li>控制的效果，例如直接限流、冷启动、排队等。</li>
</ul>
<p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p>
<h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a><strong><strong>熔断降级</strong></strong></h3><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p>
<p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p>
<p>Hystrix 通过<a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池</a>的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。</p>
<p>Sentinel 对这个问题采取了两种手段:</p>
<ul>
<li>通过并发线程数进行限制</li>
</ul>
<p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p>
<ul>
<li>通过响应时间对资源进行降级</li>
</ul>
<p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p>
<h3 id="系统负载保护"><a href="#系统负载保护" class="headerlink" title="系统负载保护"></a><strong><strong>系统负载保护</strong></strong></h3><p>Sentinel 同时提供<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/system-adaptive-protection.html">系统维度的自适应保护能力</a>。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p>
<p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>
<p>更多的能力项介绍详见《<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/golang/basic-api-usage.html">官方文档</a>》。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><hr>
<p>用户接入使用 Sentinel Go (后文均用 Sentinel 表示 Sentinel Go) 主要需要需要以下几步：</p>
<ol>
<li>对 Sentinel 的运行环境进行相关配置并初始化。API 接口使用细节可以参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/sentinel-golang/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE">配置方式</a></li>
<li>埋点（定义资源），该步骤主要是确定系统中有哪些资源需要防护，资源定义可参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/sentinel-golang/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97">新手指南</a></li>
<li>配置规则，该步骤主要是为每个资源都配置具体的规则，规则的配置可参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/sentinel-golang/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97">新手指南</a> 以及各个模块的使用文档。</li>
<li>编写资源防护的入口和出口代码。释放方式可参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/sentinel-golang/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97">新手指南</a></li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>典型配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="attr">sentinel:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-go-demo</span></span><br><span class="line">    <span class="attr">type:</span> <span class="number">0</span> <span class="comment"># 项目类型</span></span><br><span class="line">  <span class="attr">log:</span></span><br><span class="line">    <span class="attr">dir:</span> <span class="string">&quot;~/logs/csp&quot;</span></span><br><span class="line">    <span class="attr">pid:</span> <span class="literal">false</span> <span class="comment"># 监控日志文件名是否带上进程 PID，参数名称应该是usePid？</span></span><br><span class="line">    <span class="attr">metric:</span></span><br><span class="line">      <span class="attr">maxFileCount:</span> <span class="number">14</span></span><br><span class="line">      <span class="attr">flushIntervalSec:</span> <span class="number">1</span> <span class="comment"># 监控日志聚合和刷盘的时间频率</span></span><br><span class="line">      <span class="attr">singleFileMaxSize:</span> <span class="number">1024000</span> <span class="comment"># 日志文件大小</span></span><br><span class="line">  <span class="attr">stat:</span></span><br><span class="line">    <span class="attr">globalStatisticSampleCountTotal:</span> <span class="number">20</span> <span class="comment"># 资源的bucket个数，默认20个bucket</span></span><br><span class="line">    <span class="attr">globalStatisticIntervalMsTotal:</span> <span class="number">10000</span> <span class="comment"># 资源默认统计时长</span></span><br><span class="line">    <span class="attr">metricStatisticSampleCount:</span> <span class="number">2</span> </span><br><span class="line">    <span class="attr">metricStatisticIntervalMs:</span> <span class="number">1000</span></span><br><span class="line">    <span class="attr">system:</span></span><br><span class="line">      <span class="attr">collectIntervalMs:</span> <span class="number">1000</span> <span class="comment"># 下面三个统计周期的默认值</span></span><br><span class="line">          <span class="attr">collectLoadIntervalMs:</span> <span class="number">1000</span> <span class="comment"># 负载统计周期</span></span><br><span class="line">          <span class="attr">collectCpuIntervalMs:</span> <span class="number">1000</span> <span class="comment"># cpu统计周期</span></span><br><span class="line">          <span class="attr">collectMemoryIntervalMs:</span> <span class="number">150</span> <span class="comment"># 内存统计周期</span></span><br><span class="line">            </span><br><span class="line">  <span class="attr">export:</span></span><br><span class="line">    <span class="attr">metric:</span> <span class="comment"># 本地Prometheus配置</span></span><br><span class="line">        <span class="attr">http_addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080</span></span><br><span class="line">      <span class="attr">http_path:</span> <span class="string">/metrics</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">useCacheTime:</span> <span class="literal">true</span> <span class="comment"># 时间更新定时器，减少系统调用对性能开销的影响</span></span><br></pre></td></tr></table></figure>

<h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p>定义各种资源以及流量控制阈值及触发动作。支持两种规则配置方式：</p>
<p>1、hardcode编码：使用LoadRules手动加载。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err = flow.LoadRules([]*flow.Rule&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Resource:               <span class="string">&quot;some-test-rule&quot;</span>,</span><br><span class="line">        Threshold:              <span class="number">10</span>,</span><br><span class="line">        TokenCalculateStrategy: flow.Direct,</span><br><span class="line">        ControlBehavior:        flow.Reject,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>2、动态数据源</p>
<p>Sentinel 提供动态数据源接口进行扩展，用户可以通过动态文件、etcd、consul、nacos 等配置中心来动态地配置规则。详情请参考<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/golang/dynamic-data-source-usage.html">动态数据源使用文档</a>。</p>
<h3 id="埋点（资源访问）"><a href="#埋点（资源访问）" class="headerlink" title="埋点（资源访问）"></a>埋点（资源访问）</h3><p>使用 Sentinel 的 Entry API 将业务逻辑封装起来，这一步称为“埋点”。每个埋点都有一个资源名称（resource），代表触发了这个资源的调用或访问。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EntryOptions represents the options of a Sentinel resource entry.</span></span><br><span class="line"><span class="keyword">type</span> EntryOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    resourceType base.ResourceType <span class="comment">// 资源类型，rpc、web、api、sql等。有什么作用？</span></span><br><span class="line">    entryType    base.TrafficType  <span class="comment">// Inbound、Outbound。有什么作用？</span></span><br><span class="line">    batchCount   <span class="type">uint32</span> <span class="comment">// 标记每次触发该埋点计为几次调用</span></span><br><span class="line">    flag         <span class="type">int32</span>  <span class="comment">// ???</span></span><br><span class="line">    slotChain    *base.SlotChain <span class="comment">// 埋点执行的检查的slotchain，若不指定，默认使用全局slotchain</span></span><br><span class="line">    args         []<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 埋点携带的参数列表，为热点参数统计预留。</span></span><br><span class="line">    attachments  <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// resource entry with the given k-v pairs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry 方法用于埋点</span></span><br><span class="line">e, b := sentinel.Entry(<span class="string">&quot;some-test-rule&quot;</span>, sentinel.WithTrafficType(base.Inbound))</span><br><span class="line"><span class="keyword">if</span> b != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 请求被流控，可以从 BlockError 中获取限流详情</span></span><br><span class="line">    <span class="comment">// block 后不需要进行 Exit()</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 请求可以通过，在此处编写您的业务逻辑</span></span><br><span class="line">    <span class="comment">// 务必保证业务逻辑结束后 Exit</span></span><br><span class="line">    e.Exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="资源防护的入口和出口代码"><a href="#资源防护的入口和出口代码" class="headerlink" title="资源防护的入口和出口代码"></a>资源防护的入口和出口代码</h3><p>对请求被拦截和通过时的处理。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><hr>
<p>Sentinel 的主要工作机制如下：</p>
<ul>
<li>对主流框架提供适配或者显示的 API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。</li>
<li>根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel 提供开放的接口，方便您定义及改变规则。</li>
<li>Sentinel 提供实时的监控系统，方便您快速了解目前系统的状态。</li>
</ul>
<h3 id="流量控制-1"><a href="#流量控制-1" class="headerlink" title="流量控制"></a>流量控制</h3><hr>
<p>流量控制(flow control)，其原理是监控资源(<code>Resource</code>)的统计指标，然后根据 token 计算策略来计算资源的可用 token(也就是阈值)，然后根据流量控制策略对请求进行控制，避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p>
<p>Sentinel 通过定义流控规则来实现对 <code>Resource</code> 的流量控制。在 Sentinel 内部会在加载流控规则时候将每个 flow.Rule 都会被转换成流量控制器(TrafficShapingController)。 每个流量控制器实例都会有自己独立的统计结构，这里统计结构是一个滑动窗口。Sentinel 内部会尽可能复用 Resource 级别的全局滑动窗口，如果流控规则的统计设置没法复用Resource的全局统计结构，那么Sentinel会为流量控制器创建一个全新的私有的滑动窗口，然后通过 flow.StandaloneStatSlot 这个统计Slot来维护统计指标。</p>
<p><strong>规则定义</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rule <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID <span class="type">string</span> <span class="string">`json:&quot;id,omitempty&quot;`</span> <span class="comment">// 资源id（可选）</span></span><br><span class="line">    Resource               <span class="type">string</span>                 <span class="string">`json:&quot;resource&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阈值计算策略：Direct、WarmUp、MemoryAdaptive：Direct表示直接使用字段 Threshold 作为阈值；WarmUp表示使用预热方式计算Token的阈值</span></span><br><span class="line">    TokenCalculateStrategy TokenCalculateStrategy <span class="string">`json:&quot;tokenCalculateStrategy&quot;`</span> </span><br><span class="line">    <span class="comment">// 行为控制策略：Reject、Throttling（匀速排队）</span></span><br><span class="line">    ControlBehavior        ControlBehavior        <span class="string">`json:&quot;controlBehavior&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流控阈值；如果字段 StatIntervalInMs 是1000(也就是1秒)，那么Threshold就表示QPS</span></span><br><span class="line">    Threshold        <span class="type">float64</span>          <span class="string">`json:&quot;threshold&quot;`</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用关系限流策略，CurrentResource表示使用当前规则的resource做流控；AssociatedResource表示使用关联的resource做流控，关联的resource在字段 RefResource 定义；</span></span><br><span class="line">    RelationStrategy RelationStrategy <span class="string">`json:&quot;relationStrategy&quot;`</span> </span><br><span class="line">    RefResource      <span class="type">string</span>           <span class="string">`json:&quot;refResource&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匀速排队的最大等待时间，该字段仅仅对 Throttling ControlBehavior生效；为0时表示仅控制频率，上层执行排队</span></span><br><span class="line">    MaxQueueingTimeMs <span class="type">uint32</span> <span class="string">`json:&quot;maxQueueingTimeMs&quot;`</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// **WarmUp**策略时的相关参数，参考SmoothWarmingUp【令牌桶算法变种】</span></span><br><span class="line">    WarmUpPeriodSec   <span class="type">uint32</span> <span class="string">`json:&quot;warmUpPeriodSec&quot;`</span> <span class="comment">// 预热的时间长度，该字段仅仅对 WarmUp 的TokenCalculateStrategy生效</span></span><br><span class="line">    WarmUpColdFactor  <span class="type">uint32</span> <span class="string">`json:&quot;warmUpColdFactor&quot;`</span> <span class="comment">// 预热的因子，默认是3，该值的设置会影响预热的速度，该字段仅仅对 WarmUp 的TokenCalculateStrategy生效；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规则对应的流量控制器的独立统计结构的统计周期。如果StatIntervalInMs是1000，也就是统计QPS。</span></span><br><span class="line">    StatIntervalInMs <span class="type">uint32</span> <span class="string">`json:&quot;statIntervalInMs&quot;`</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// MemoryAdaptive策略时的相关参数：根据当前服务使用内存大小决定Threshold值，使其处于[LowMemUsageThreshold, HighMemUsageThreshold]之间。当内存位于阈值之间时按比例取值。</span></span><br><span class="line">    LowMemUsageThreshold  <span class="type">int64</span> <span class="string">`json:&quot;lowMemUsageThreshold&quot;`</span>   <span class="comment">// 当前内存 &lt; 内存最小阈值时的 ThreshHold</span></span><br><span class="line">    HighMemUsageThreshold <span class="type">int64</span> <span class="string">`json:&quot;highMemUsageThreshold&quot;`</span>  <span class="comment">// 当前内存 &gt; 内存最大阈值时的 ThreshHold。</span></span><br><span class="line">    MemLowWaterMarkBytes  <span class="type">int64</span> <span class="string">`json:&quot;memLowWaterMarkBytes&quot;`</span>   <span class="comment">// 内存最小阈值</span></span><br><span class="line">    MemHighWaterMarkBytes <span class="type">int64</span> <span class="string">`json:&quot;memHighWaterMarkBytes&quot;`</span>  <span class="comment">// 内存最大阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StatIntervalInMs</code> 和 <code>Threshold</code> 这两个字段，这两个字段决定了流量控制器的灵敏度。以 Direct + Reject 的流控策略为例，流量控制器的行为就是在 <code>StatIntervalInMs</code> 周期内，允许的最大请求数量是<code>Threshold</code>。比如如果 <code>StatIntervalInMs</code> 是 10000，<code>Threshold</code> 是10000，那么流量控制器的行为就是控制该资源10s内运行最多10000次访问。</p>
<p><strong><strong>流量控制策略</strong></strong></p>
<p>Sentinel 的流量控制策略由规则中的 <code>TokenCalculateStrategy</code> 和 <code>ControlBehavior</code> 两个字段决定。<code>TokenCalculateStrategy</code> 表示流量控制器的Token计算方式，目前Sentinel支持3种：</p>
<ol>
<li>Direct表示直接使用规则中的 <code>Threshold</code> 表示当前统计周期内的最大Token数量。</li>
<li>WarmUp表示通过预热的方式计算当前统计周期内的最大Token数量，预热的计算方式会根据规则中的字段 <code>WarmUpPeriodSec</code> 和 <code>WarmUpColdFactor</code> 来决定预热的曲线。</li>
<li>MemoryAdaptive表示根据当前内存大小以及最大、小内存阈值( <code>memLowWaterMarkBytes</code> 和 <code>memLowWaterMarkBytes</code>）的关系计算当前周期内的最大Token数，使其范围位于[ <code>lowMemUsageThreshold</code> , <code>highMemUsageThreshold</code>]之间。</li>
</ol>
<p>WarmUp 方式，即预热&#x2F;冷启动方式。当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。这块设计和 Java 类似，可以参考<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">限流-冷启动文档</a></p>
<p><img src="https://user-images.githubusercontent.com/9434884/68292392-b5b0aa00-00c6-11ea-86e1-ecacff8aab51.png" alt="https://user-images.githubusercontent.com/9434884/68292392-b5b0aa00-00c6-11ea-86e1-ecacff8aab51.png"></p>
<p>字段 <code>ControlBehavior</code> 表示表示流量控制器的控制行为，目前 Sentinel 支持两种控制行为：</p>
<ol>
<li>Reject：表示如果当前统计周期内，统计结构统计的请求数超过了阈值，就直接拒绝。</li>
<li>Throttling：表示匀速排队的统计策略。它的中心思想是，以固定的间隔时间让请求通过。当请求到来的时候，如果当前请求距离上个通过的请求通过的时间间隔不小于预设值，则让当前请求通过；否则，计算当前请求的预期通过时间，如果该请求的预期通过时间小于规则预设的 timeout 时间，则该请求会等待直到预设时间到来通过（排队等待处理）；若预期的通过时间超出最大排队时长，则直接拒接这个请求。</li>
</ol>
<p>匀速排队方式会严格控制请求通过的间隔时间，也即是让请求以均匀的速度通过，对应的是漏桶算法。这种方式主要用于处理间隔性突发的流量，例如消息队列。</p>
<p><strong><strong>流量控制器的统计结构</strong></strong></p>
<p>每个流量控制器实例都会有自己独立的统计结构。流量控制器的统计结构由规则中的 <code>StatIntervalInMs</code> 字段设置，<code>StatIntervalInMs</code>表示统计结构的统计周期。Sentinel 默认会为每个Resource创建一个全局的滑动窗口统计结构，这个全局的统计结构默认是一个间隔为10s,20个格子的滑动窗口，也就是每个统计窗口长度是500ms。</p>
<p>流量控制器实例会尽可能复用这个Resource级别的全局统计结构，复用逻辑原则是：优先复用Resource级别的全局统计结构，如果不可复用，就重新创建一个独立的滑动窗口统计结构(BucketLeapArray)，具体的逻辑细节如下：</p>
<ol>
<li>如果<code>StatIntervalInMs</code>大于全局滑动窗口的间隔(默认10s)，那么将不可复用全局统计结构。Sentinel会给流量控制器创建一个长度是<code>StatIntervalInMs</code>，格子数是1的全新统计结构，这个全新的统计结构由Sentinel内部的<code>StandaloneStatSlot</code>来维护统计。</li>
<li>如果<code>StatIntervalInMs</code>小于全局滑动窗口的窗口长度(默认是500ms), 那么将不可复用全局统计结构。Sentinel会给流量控制器创建一个长度是<code>StatIntervalInMs</code>，格子数是1的全新统计结构，这个全新的统计结构由Sentinel内部的<code>StandaloneStatSlot</code>来维护统计。</li>
<li>如果<code>StatIntervalInMs</code>在集合[全局滑动窗口的窗口长度，全局滑动窗口的间隔]之间，首先需要计算格子数：如果<code>StatIntervalInMs</code>可以被全局滑动窗口的窗口长度(默认是500ms)整除，那么格子数就为 <code>StatIntervalInMs</code>&#x2F;<code>GlobalStatisticBucketLengthInMs</code>，如果不可整除，格子数是1。然后会调用 <code>core/base/CheckValidityForReuseStatistic</code>函数来判断当前统计结构间隔和格子数是否可以复用全局统计结构。如果可以复用，就会基于resource级别的全局统计结构<code>ResourceNode</code>创建<code>SlidingWindow</code>，SlidingWindow是一个虚拟结构，SlidingWindow只可读，而且读的数据是通过聚合<code>ResourceNode</code>数据得到的。如果不可复用，就使用统计结构间隔和格子数创建全新的滑动窗口(BucketLeapArray)。</li>
</ol>
<p>CheckValidityForReuseStatistic函数参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/sentinel-golang/blob/master/core/base/stat.go">https://github.com/alibaba/sentinel-golang/blob/master/core/base/stat.go#func CheckValidityForReuseStatistic</a></p>
<p>基于规则创建统计结构的逻辑参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/sentinel-golang/blob/master/core/flow/rule_manager.go">https://github.com/alibaba/sentinel-golang/blob/master/core/flow/rule_manager.go#func generateStatFor</a></p>
<p><strong><strong>常见场景的规则配置</strong></strong></p>
<ul>
<li>基于QPS对某个资源限流：常规场景，StatIntervalInMs为1s时Threshold所配置的值也就是QPS的阈值。</li>
<li>基于一定统计间隔时间来控制总的请求数：允许在一定统计周期内控制请求的总量。但是这种流控配置对于脉冲类型的流量抵抗力很弱，有极大潜在风险压垮系统。</li>
<li>毫秒级别流控：建议<code>StatIntervalInMs</code>的配置在毫秒级别，除非特殊场景，建议配置的值为100ms的倍数。这种配置能够很好的应对脉冲流量，保障系统稳定性。</li>
<li>脉冲流量无损：前面第三点场景，如果既想控制流量曲线，又想无损，一般做法是通过匀速排队的控制策略，平滑掉流量。</li>
<li>基于调用关系的流量控制：当两个资源之间具有资源争抢或者依赖关系的时候，这两个资源便具有了关联。比如对数据库同一个字段的读操作和写操作存在争抢，读的速度过高会影响写得速度，写的速度过高会影响读的速度。如果放任读写操作争抢资源，则争抢本身带来的开销会降低整体的吞吐量。可使用关联限流来避免具有关联关系的资源之间过度的争抢。</li>
</ul>
<h3 id="熔断降级-1"><a href="#熔断降级-1" class="headerlink" title="熔断降级"></a><strong><strong>熔断降级</strong></strong></h3><hr>
<p>熔断器有三种状态：</p>
<ol>
<li>Closed 状态：也是初始状态，该状态下，熔断器会保持闭合，对资源的访问直接通过熔断器的检查。</li>
<li>Open 状态：断开状态，熔断器处于开启状态，对资源的访问会被切断。</li>
<li>Half-Open 状态：半开状态，该状态下除了探测流量，其余对资源的访问也会被切断。探测流量指熔断器处于半开状态时，会周期性的允许一定数目的探测请求通过，如果探测请求能够正常的返回，代表探测成功，此时熔断器会重置状态到 Closed 状态，结束熔断；如果探测失败，则回滚到 Open 状态。</li>
</ol>
<p>Sentinel 提供了监听器去监听熔断器状态机的三种状态的转换，方便用户去自定义扩展：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StateChangeListener listens on the circuit breaker state change event.</span></span><br><span class="line"><span class="keyword">type</span> StateChangeListener <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// 熔断器切换到 Closed 状态时候会调用改函数, prev代表切换前的状态，rule表示当前熔断器对应的规则</span></span><br><span class="line">    OnTransformToClosed(prev State, rule Rule)</span><br><span class="line">        <span class="comment">// 熔断器切换到 Open 状态时候会调用改函数, prev代表切换前的状态，rule表示当前熔断器对应的规则， snapshot表示触发熔断的值</span></span><br><span class="line">    OnTransformToOpen(prev State, rule Rule, snapshot <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">        <span class="comment">// 熔断器切换到 HalfOpen 状态时候会调用改函数, prev代表切换前的状态，rule表示当前熔断器对应的规则</span></span><br><span class="line">    OnTransformToHalfOpen(prev State, rule Rule)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><strong>熔断器的设计</strong></strong></p>
<p>衡量下游服务质量时候，场景的指标就是RT(response time)、异常数量以及异常比例等等。Sentinel 的熔断器支持三种熔断策略：慢调用比例熔断、异常比例熔断以及异常数量熔断。</p>
<p>用户通过设置熔断规则(Rule)来给资源添加熔断器。Sentinel会将每一个熔断规则转换成对应的熔断器，熔断器对用户是不可见的。Sentinel 的每个熔断器都会有自己独立的统计结构。</p>
<p>熔断器的整体检查逻辑可以用几点来精简概括：</p>
<ol>
<li>基于熔断器的状态机来判断对资源是否可以访问；</li>
<li>对不可访问的资源会有探测机制，探测机制保障了对资源访问的弹性恢复；</li>
<li>熔断器会在对资源访问的完成态去更新统计，然后基于熔断规则更新熔断器状态机。</li>
</ol>
<p><strong><strong>熔断策略</strong></strong></p>
<p>Sentinel 熔断器的三种熔断策略都支持静默期 (规则中通过MinRequestAmount字段表示)来降低误判的可能性。静默期是指一个最小的静默请求数，在一个统计周期内，如果对资源的请求数小于设置的静默数，那么熔断器将不会基于其统计值去更改熔断器的状态。</p>
<p>Sentinel 支持以下几种熔断策略：</p>
<ul>
<li>慢调用比例策略 (SlowRequestRatio)：Sentinel 的熔断器不在静默期，并且慢调用的比例大于设置的阈值，则接下来的熔断周期内对资源的访问会自动地被熔断。该策略下需要设置允许的调用 RT 临界值（即最大的响应时间），对该资源访问的响应时间大于该阈值则统计为慢调用。</li>
<li>错误比例策略 (ErrorRatio)：Sentinel 的熔断器不在静默期，并且在统计周期内资源请求访问异常的比例大于设定的阈值，则接下来的熔断周期内对资源的访问会自动地被熔断。</li>
<li>错误计数策略 (ErrorCount)：Sentinel 的熔断器不在静默期，并且在统计周期内资源请求访问异常数大于设定的阈值，则接下来的熔断周期内对资源的访问会自动地被熔断。</li>
</ul>
<p>注意：这里的错误比例熔断和错误计数熔断指的业务返回错误的比例或则计数。也就是说，如果规则指定熔断器策略采用错误比例或则错误计数，那么为了统计错误比例或错误计数，需要调用API： <code>api.TraceError(entry, err)</code> 埋点每个请求的业务异常。</p>
<p><strong><strong>熔断降级规则定义</strong></strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rule encompasses the fields of circuit breaking rule.</span></span><br><span class="line"><span class="keyword">type</span> Rule <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 表示 Sentinel 规则的全局唯一ID，可选项。</span></span><br><span class="line">    Id <span class="type">string</span> <span class="string">`json:&quot;id,omitempty&quot;`</span></span><br><span class="line">    <span class="comment">// 熔断器规则生效的埋点资源的名称</span></span><br><span class="line">    Resource <span class="type">string</span>   <span class="string">`json:&quot;resource&quot;`</span></span><br><span class="line">    <span class="comment">// 熔断策略，目前支持SlowRequestRatio、ErrorRatio、ErrorCount三种；</span></span><br><span class="line">    Strategy Strategy <span class="string">`json:&quot;strategy&quot;`</span></span><br><span class="line">    <span class="comment">// 即熔断触发后持续的时间（单位为 ms）。资源进入熔断状态后，在配置的熔断时长内，请求都会快速失败。熔断结束后进入探测恢复模式（HALF-OPEN）。</span></span><br><span class="line">    RetryTimeoutMs <span class="type">uint32</span> <span class="string">`json:&quot;retryTimeoutMs&quot;`</span></span><br><span class="line">    <span class="comment">// 静默数量，如果当前统计周期内对资源的访问数量小于静默数量，那么熔断器就处于静默期。</span></span><br><span class="line">    MinRequestAmount <span class="type">uint64</span> <span class="string">`json:&quot;minRequestAmount&quot;`</span></span><br><span class="line">    <span class="comment">// 统计的时间窗口长度（单位为 ms）。</span></span><br><span class="line">    StatIntervalMs <span class="type">uint32</span> <span class="string">`json:&quot;statIntervalMs&quot;`</span></span><br><span class="line">    <span class="comment">// ?</span></span><br><span class="line">    StatSlidingWindowBucketCount <span class="type">uint32</span> <span class="string">`json:&quot;statSlidingWindowBucketCount&quot;`</span></span><br><span class="line">    <span class="comment">// 仅对慢调用熔断策略生效，MaxAllowedRtMs 是判断请求是否是慢调用的临界值，也就是如果请求的response time小于或等于MaxAllowedRtMs，那么就不是慢调用；</span></span><br><span class="line">    MaxAllowedRtMs <span class="type">uint64</span> <span class="string">`json:&quot;maxAllowedRtMs&quot;`</span></span><br><span class="line">    <span class="comment">// 对于慢调用熔断策略, Threshold表示是慢调用比例的阈值(小数表示，比如0.1表示10%)，也就是如果当前资源的慢调用比例如果高于Threshold，那么熔断器就会断开；否则保持闭合状态。 对于错误比例策略，Threshold表示的是错误比例的阈值(小数表示，比如0.1表示10%)。对于错误数策略，Threshold是错误计数的阈值。</span></span><br><span class="line">    Threshold <span class="type">float64</span> <span class="string">`json:&quot;threshold&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── api</span><br><span class="line">│   ├── api.go              <span class="comment"># Entry相关对外API</span></span><br><span class="line">│   ├── init.go             <span class="comment"># sentinel初始化（配置）</span></span><br><span class="line">│   ├── slot_chain.go       <span class="comment"># 默认SlotChain（用于控制检查流程）</span></span><br><span class="line">│   ├── tracer.go</span><br><span class="line">├── core</span><br><span class="line">│   ├── base                <span class="comment"># 基础数据结构定义</span></span><br><span class="line">│   ├── circuitbreaker      <span class="comment"># 功能模块：熔断降级实现（含相关规则Rule定义、管理RuleManager以及检查逻辑Slot，其他功能类似）</span></span><br><span class="line">│   ├── config              <span class="comment"># 全局配置解析</span></span><br><span class="line">│   ├── flow                <span class="comment"># 功能模块：流量控制实现</span></span><br><span class="line">│   ├── hotspot             <span class="comment"># 功能模块：热点参数留空</span></span><br><span class="line">│   ├── isolation           <span class="comment"># 功能模块：并发隔离控制</span></span><br><span class="line">│   ├── <span class="built_in">log</span>                 </span><br><span class="line">│   ├── <span class="built_in">stat</span>                <span class="comment"># 流量统计数据结构</span></span><br><span class="line">│   ├── system              <span class="comment"># 功能模块：系统自适应保护</span></span><br><span class="line">│   └── system_metric       <span class="comment"># 服务指标监控，cpu、内存、load等</span></span><br><span class="line">├── exporter</span><br><span class="line">│   └── metric              <span class="comment"># Prometheus上报</span></span><br><span class="line">├── logging</span><br><span class="line">│   ├── logging.go          <span class="comment"># 日志</span></span><br><span class="line">│   └── logging_test.go</span><br></pre></td></tr></table></figure>

<p>如上，几个核心功能（流量控制、熔断降级、并发隔离等）都是按目录分别存放，每个目录整体结构类似，可以分为规则解析、行为控制以及slot检查逻辑三部分。最后使用责任链模式，将各个模块在Entry入口处使用SlotChain串联起来遍历调用。</p>
<p>此处仅分析流量控制模块相关的流程及数据结构，包括部分公共模块。</p>
<h3 id="sentinel初始化"><a href="#sentinel初始化" class="headerlink" title="sentinel初始化"></a>sentinel初始化</h3><p>入口：InitWithConfigFile、InitDefault</p>
<p>目的：从配置文件读取、解析配置，并执行初始化动作</p>
<p>流程：</p>
<ol>
<li>yaml配置解析，格式见上方的典型配置。<ol>
<li>校验字段有效性，重点关注stat中的几个流量控制器统计相关的<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/golang/flow-control.html">参数</a>。</li>
</ol>
</li>
<li>从env中读取配置，目的是为了支持通过环境变量控制AppName、AppType、LogPath等参数。</li>
<li>初始化日志：基于标准库log.Logger封装日志lib。参考logging&#x2F;下实现。</li>
<li>核心公共component（goroutine协程）初始化，用于辅助后面的流控逻辑。<ol>
<li>日志定时flush任务开启（配置开关）。</li>
<li>启动三个系统指标（load、cpu、mem）的收集定时器，定期采集并（原子操作）存储到内存。方案使用<a target="_blank" rel="noopener" href="https://github.com/shirou/gopsutil">gopsutil</a>实现，cpu、mem数据会用于Prometheus上报，cpu、load数据会用作规则校验。（AdaptiveSlot.doCheckRule）</li>
<li>开启时间更新定时器（UseCacheTime），降低频繁的时间采集调用对系统的影响。大流量系统建议开启。</li>
<li>开启Prometheus export服务（http server），会影响来自Prometheus服务端的定期收集。详见metric_exporter.HTTPHandler实现。</li>
</ol>
</li>
</ol>
<h3 id="流量控制规则初始化"><a href="#流量控制规则初始化" class="headerlink" title="流量控制规则初始化"></a>流量控制规则初始化</h3><p>入口：flow.LoadRule</p>
<p>目的：将每个资源的规则转列表换为流量控制器的列表，用于后续的资源访问（埋点）。</p>
<p>流程：</p>
<p><strong>rule_manager：</strong>维护全局的规则map，结构 map[string][]*Rule，即规则名 → 规则列表的映射。</p>
<p>规则加载LoadRules：</p>
<ol>
<li>每次LoadRules时会从使用新的规则替换之前已有的全部资源+规则，非法的Rule会被过滤。或者使用LoadRulesOfResource替换某个资源的全部规则。为何Resouce不能动态新增规则？</li>
<li>协程安全：使用了atomic允许多个goroutine并行Load</li>
<li>资源的规则列表*[]<em>Rule</em>数据会转换为流量控制器**[]TrafficShapingController*列表，用于执行真实的流量控制。</li>
<li>全局对象tcMap维护资源到TrafficShapingController列表的映射，供后续查询等处理。</li>
<li>全局对象currentRules记录规则的列表。如果重复加载相同规则集不会做任何初始化动作。</li>
</ol>
<p>重点逻辑为构建流量控制器列表，在分析其逻辑之前，先看下流量控制器TrafficShapingController的具体定义。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TrafficSharpingController代码了单条Rule对应流量计算 + 流量控制行为</span></span><br><span class="line"><span class="keyword">type</span> **TrafficShapingController** <span class="keyword">struct</span> &#123;</span><br><span class="line">    flowCalculator TrafficShapingCalculator <span class="comment">// 表示流量控制器的Token计算方式，返回当前流量控制的阈值，存在 Direct/WarmUp(预热)/MemoryAdaptive三种</span></span><br><span class="line">    flowChecker    TrafficShapingChecker    <span class="comment">// 表示表示流量控制器的控制行为，存在 Reject/Throttling(排队)两种</span></span><br><span class="line"></span><br><span class="line">    rule *Rule <span class="comment">// 指向原Rule对象</span></span><br><span class="line">    <span class="comment">// boundStat is the statistic of current TrafficShapingController</span></span><br><span class="line">    boundStat standaloneStatistic  <span class="comment">// 当前流量统计</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流量控制器的作用就是根据当前流量数据，与阈值计算器返回的当前阈值比较，然后根据比较结果以及行为控制器的配置，来告诉调用方采取何种动作（放过、Block或者排队）。构建流量控制器的行为就是将原始的Rule转换为流量控制器的过程（buildResourceTrafficShapingController）：</p>
<ol>
<li>每条Rule对应一条单独的流量控制器，即使同一资源存在多条重复规则，也会生成不同的Controller各自计算。</li>
<li>构建过程中如果之前已经有可复用的Controller了会被复用（复用条件：规则条件完全一致或者部分一致，见isStatReusable()） —— 复用有条件，所以服务在运行过程中规则有变更时需要考虑是否可能存在断时间控制未生效的情况。</li>
<li>构建TrafficShapingController，重点是计算器flowCalculator和控制器flowChecker的选择方式，会依赖规则的TokenCalculateStrategy、ControlBehavior。目前实现了3种计算器和2种行为控制器。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阈值（Threshold）计算</span></span><br><span class="line"><span class="keyword">type</span> TrafficShapingCalculator <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 指回流量控制的指针</span></span><br><span class="line">    BoundOwner() *TrafficShapingController</span><br><span class="line">    <span class="comment">// 根据tokenCalculateStrategy返回Token阈值。</span></span><br><span class="line">    <span class="comment">// - 如果是Direct类型，则为Threshold固定值；</span></span><br><span class="line">    <span class="comment">// - 如果是WarmUp类型，使用SmoothWarmingUp算法【令牌桶变种】动态计算；</span></span><br><span class="line">    <span class="comment">// - 如果是MemoryAdaptive类型，根据内存大小动态计算Threshold</span></span><br><span class="line">    CalculateAllowedTokens(batchCount <span class="type">uint32</span>, flag <span class="type">int32</span>) <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为控制</span></span><br><span class="line"><span class="keyword">type</span> TrafficShapingChecker <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 指回流量控制的指针</span></span><br><span class="line">    BoundOwner() *TrafficShapingController</span><br><span class="line">    <span class="comment">// 根据当前stat计数、需要消耗的token数量以及threshold，计算控制结果。并根据controlBehavior的类型返回对应的检查结果：</span></span><br><span class="line">    <span class="comment">// - 如果是Reject：如果达到阈值，返回status为ResultStatusBlocked的TokenResult。否则返回nil</span></span><br><span class="line">    <span class="comment">// - 如果是Throttling：存在三种可能</span></span><br><span class="line">    <span class="comment">//    1. 如果很久没有排队校验请求了（上次排队耗时+处理耗时 &lt; 当前时间），直接返回nil表示放过</span></span><br><span class="line">    <span class="comment">//    2. 如果预估排队（预估请求被处理的时间-当前时间）耗时超过了MaxQueueingTimeMs，返回status为ResultStatusBlocked的TokenResult()。</span></span><br><span class="line">    <span class="comment">//    3. 否则返回状态为ResultStatusShouldWait的TokenResult给到上层（SlotChain），表示允许排队等待</span></span><br><span class="line">    DoCheck(resStat base.StatNode, batchCount <span class="type">uint32</span>, threshold <span class="type">float64</span>) *base.TokenResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三种阈值计算器：</strong></p>
<ul>
<li>DirectTrafficShapingCalculator：直接使用固定值threshold作为阈值。</li>
<li>TrafficShapingCalculator：使用冷启动算法计算当前阈值，算法参考《<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">官方说明</a>》。使用系统启动需要预热的场景，避免短时间的流量高峰将系统冲垮。</li>
<li>MemoryAdaptiveTrafficShapingCalculator：根据当前服务内存占用以及相关配置，动态计算使其处于[LowMemUsageThreshold, HighMemUsageThreshold]之间。当内存位于阈值之间时按比例取值。注意这里要配置好Rule中内存相关的四个参数值。</li>
</ul>
<p><strong>两种行为控制器：</strong></p>
<ul>
<li>RejectTrafficShapingChecker：如果当前token计数大于计算器返回的阈值，直接返回rejectTokenResult(state: ResultStatusBlocked, msg: “flow reject check blocked”），否则表示通过返回nil</li>
<li>ThrottlingChecker：目的是期望当token数超过了匀速排队的阈值时以排队的方式让上层等待或者sleep，而非直接丢弃。代码中的几个实现细节：<ul>
<li>此处<strong>匀速排队</strong>的意思是指StatIntervalInMs&#x2F;Threshold来计算每一个token的速度，而非StatIntervalInMs时间内通过Threshold后其余数据排队。比如设置qps为5（StatIntervalInMs:1000, Threshold为5），那么匀速就是指每200ms只允许通过1次请求，如果两次请求的间隔时间小于200ms，那么会被立即要求排队，而非等到1000ms内的5个请求之后。。</li>
<li>需要考虑并发场景，所以控制器维护了一个lastPassedTime的属性，用于记录已排队到的时间戳，记住更新、读取时需要原子操作。由于lastPassedTime即可反应当前的排队请求，所以ThrottlingChecker也<strong>不需要流量统计数据结构</strong>，仅需要更新lastPassedTime数据即可。</li>
<li>预估排队耗时无法精确，只能根据阈值threshHold和统计时长statIntervalInMs预估系统的处理速度，然后根据token数（batchCount）估算</li>
<li>允许排队时，返回特定TokenResult（state：ResultStatusShouldWait），供上层或者sentinel执行排队处理。根据是否指定最大排队耗时MaxQueueingTimeMs，区分两种情况。<ul>
<li>不指定最大排队耗时，则直接返回给上层，由业务自行决定如何处理。</li>
<li>指定了最大排队耗时，怎在执行规则匹配（资源访问）时会Sleep一段时间，保障上层调用能够匀速处理。—— 注意这里可能会导致上层处理被临时block一段时间，导致服务内存的堆积。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ThrottlingChecker)</span></span> DoCheck(_ base.StatNode, batchCount <span class="type">uint32</span>, threshold <span class="type">float64</span>) *base.TokenResult &#123;</span><br><span class="line">    <span class="comment">// Pass when batch count is less or equal than 0.</span></span><br><span class="line">    <span class="keyword">if</span> batchCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> rule *Rule</span><br><span class="line">    <span class="keyword">if</span> c.BoundOwner() != <span class="literal">nil</span> &#123;</span><br><span class="line">        rule = c.BoundOwner().BoundRule()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> threshold &lt;= <span class="number">0.0</span> &#123;</span><br><span class="line">        msg := <span class="string">&quot;flow throttling check blocked, threshold is &lt;= 0.0&quot;</span></span><br><span class="line">        <span class="keyword">return</span> base.NewTokenResultBlockedWithCause(base.BlockTypeFlow, msg, rule, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">float64</span>(batchCount) &gt; threshold &#123;</span><br><span class="line">        <span class="keyword">return</span> base.NewTokenResultBlocked(base.BlockTypeFlow)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Here we use nanosecond so that we could control the queueing time more accurately.</span></span><br><span class="line">    curNano := <span class="type">int64</span>(util.CurrentTimeNano())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The interval between two requests (in nanoseconds). 预计要排队的耗时时长</span></span><br><span class="line">    intervalNs := <span class="type">int64</span>(math.Ceil(<span class="type">float64</span>(batchCount) / threshold * <span class="type">float64</span>(c.statIntervalNs)))</span><br><span class="line"></span><br><span class="line">    loadedLastPassedTime := atomic.LoadInt64(&amp;c.lastPassedTime)</span><br><span class="line">    <span class="comment">// Expected pass time of this request.</span></span><br><span class="line">    expectedTime := loadedLastPassedTime + intervalNs</span><br><span class="line">    <span class="keyword">if</span> expectedTime &lt;= curNano &#123; <span class="comment">// 可能为lastPassedTime很久没更新了，直接放过</span></span><br><span class="line">        <span class="keyword">if</span> swapped := atomic.CompareAndSwapInt64(&amp;c.lastPassedTime, loadedLastPassedTime, curNano); swapped &#123;</span><br><span class="line">            <span class="comment">// nil means pass</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预估还需排队等待耗时，如果已经超过最大排队等待时间，则直接返回blocked</span></span><br><span class="line">    estimatedQueueingDuration := atomic.LoadInt64(&amp;c.lastPassedTime) + intervalNs - curNano</span><br><span class="line">    <span class="keyword">if</span> estimatedQueueingDuration &gt; c.maxQueueingTimeNs &#123;</span><br><span class="line">        <span class="keyword">return</span> base.NewTokenResultBlockedWithCause(base.BlockTypeFlow, BlockMsgQueueing, rule, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预估排队时间可能不会超过最大等待时间，将处理耗时累加到lastPassedTime（原子化操作）</span></span><br><span class="line">    oldTime := atomic.AddInt64(&amp;c.lastPassedTime, intervalNs)</span><br><span class="line">    estimatedQueueingDuration = oldTime - curNano</span><br><span class="line">    <span class="comment">// 累加后的等待耗时大于最大等待时间，则直接返回blocked，且回退累加值</span></span><br><span class="line">    <span class="keyword">if</span> estimatedQueueingDuration &gt; c.maxQueueingTimeNs &#123;</span><br><span class="line">        <span class="comment">// Subtract the interval.</span></span><br><span class="line">        atomic.AddInt64(&amp;c.lastPassedTime, -intervalNs)</span><br><span class="line">        <span class="keyword">return</span> base.NewTokenResultBlockedWithCause(base.BlockTypeFlow, BlockMsgQueueing, rule, <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩余场景表示允许排队，返回状态为ResultStatusShouldWait的TokenResult，表示需要等待</span></span><br><span class="line">    <span class="keyword">if</span> estimatedQueueingDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 在slot中会sleep一段时间</span></span><br><span class="line">        <span class="keyword">return</span> base.NewTokenResultShouldWait(time.Duration(estimatedQueueingDuration))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> base.NewTokenResultShouldWait(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了Warmup的计算逻辑稍微麻烦点外，阈值计算器和行为控制器的逻辑都比较简单且独立。可以直接看相关代码。</p>
<p>除了以上部分，稍复杂的部分就是流量统计数结构的设计了。此部分单独介绍。</p>
<h3 id="流量统计数据结构"><a href="#流量统计数据结构" class="headerlink" title="流量统计数据结构"></a><strong>流量统计数据结构</strong></h3><hr>
<p>流量统计数据结构构建其实也是初始化规则的一部分，因流程比较复杂，此处单独抽取介绍。</p>
<p>在构造流量控制器的最后一步就是生成流量统计结构standaloneStatistic（流程见generateStatFor），并将其绑定到流量控制器用于读写流量token计数。核心数据结构是使用滑动窗口来实现，下面介绍几个核心数据结构。</p>
<p>流量统计的整体结构是基于滑动窗口来实现的，为了将流控实现足够均匀，将滑动窗口拆分多尽量细致的多个bucket，每个bucket只记录很短一段时间的数据。如果需要统计一段周期内的流量，只需要从滑动窗口中取出一段周期内的bucket数据累加即可。以周期周期1s为例，如果滑动窗口的格子只有1s，那么可能出现[500ms, 1500ms]内流量大于Threshold的情况，但是如果将滑动窗口拆分为500ms个小格子，那么统计1s的流量时就能做到足够精确。</p>
<p><strong>滑动窗口</strong></p>
<p><strong>Bucket以及LeapArray定义：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BucketWrap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// bucket的开始时间戳</span></span><br><span class="line">    BucketStart <span class="type">uint64</span></span><br><span class="line">    <span class="comment">// 存储每个bucket实际数据结构</span></span><br><span class="line">    Value atomic.Value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AtomicBucketWrapArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// The base address for real data array</span></span><br><span class="line">    base unsafe.Pointer</span><br><span class="line">    <span class="comment">// The length of slice(array), it can not be modified.</span></span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">    data   []*BucketWrap</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LeapArray represents the fundamental implementation of a sliding window data-structure.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Some important attributes: the sampleCount represents the number of buckets,</span></span><br><span class="line"><span class="comment">// while intervalInMs represents the total time span of the sliding window.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example, assuming sampleCount=5, intervalInMs is 1000ms, so the bucketLength is 200ms.</span></span><br><span class="line"><span class="comment">// Let&#x27;s give a diagram to illustrate.</span></span><br><span class="line"><span class="comment">// Suppose current timestamp is 1188, bucketLength is 200ms, intervalInMs is 1000ms, then</span></span><br><span class="line"><span class="comment">// time span of current bucket is [1000, 1200). The representation of the underlying structure:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     B0       B1      B2     B3      B4</span></span><br><span class="line"><span class="comment">//     |_______|_______|_______|_______|_______|</span></span><br><span class="line"><span class="comment">//    1000    1200    400     600     800    (1000) ms</span></span><br><span class="line"><span class="comment">//           ^</span></span><br><span class="line"><span class="comment">//        time=1188</span></span><br><span class="line"><span class="keyword">type</span> LeapArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    bucketLengthInMs <span class="type">uint32</span> <span class="comment">// 单个bucket的时间长度</span></span><br><span class="line">    <span class="comment">// sampleCount represents the number of BucketWrap.</span></span><br><span class="line">    sampleCount <span class="type">uint32</span> <span class="comment">// 滑动窗口Bucket的个数</span></span><br><span class="line">    <span class="comment">// intervalInMs represents the total time span of the sliding window (in milliseconds).</span></span><br><span class="line">    intervalInMs <span class="type">uint32</span> <span class="comment">// 滑动窗口的总跨度时长=sampleCount * bucketLengthInMs</span></span><br><span class="line">    <span class="comment">// array represents the internal circular array.</span></span><br><span class="line">    array *AtomicBucketWrapArray</span><br><span class="line">    <span class="comment">// updateLock is the internal lock for update operations.</span></span><br><span class="line">    updateLock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LeapArray为最底层的滑动窗口实现。窗口的时间长度以及BucketWrap个数由参数控制。</p>
<p><strong>BucketWrap：</strong>即为滑动窗口的最小节点，但是没有直接存储统计数据，而是存储了为保证其原子操作的atomic.Value。其真实的数据由上层generator生成并填充。</p>
<p><strong>BucketWrapArray</strong>：构造了一个以BucketWrap为节点的时间轮，并初始化每个节点。考虑到每轮周期完毕后BucketWrap会被复用，所有在其中记录了每个节点对应的时间戳，当发现数据已过期时Reset即可得到一个新的BucketWrap。</p>
<p><strong>LeapArray</strong>：BucketWrapArray上层的封装，提供了根据时间戳定位BucketWrap等能力，需要考虑并发访问、节点过期更新等场景。每次访问滑动窗口时可以根据时间戳与滑动窗口长度（ms）取模就可以定位到对应的BucketWrap。下面为根据当前时间戳获取bucket以及一段周期内数据的处理流程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间与滑动窗口长度取模，定位bucket index</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(la *LeapArray)</span></span> calculateTimeIdx(now <span class="type">uint64</span>) <span class="type">int</span> &#123;</span><br><span class="line">    timeId := now / <span class="type">uint64</span>(la.bucketLengthInMs)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int</span>(timeId) % la.array.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前时间查找对应的bucketWrap，并使用generator填充节点数据。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(la *LeapArray)</span></span> currentBucketOfTime(now <span class="type">uint64</span>, bg BucketGenerator) (*BucketWrap, <span class="type">error</span>) &#123;</span><br><span class="line">    idx := la.calculateTimeIdx(now)</span><br><span class="line">    bucketStart := calculateStartTime(now, la.bucketLengthInMs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在并发冲突场景，所以会一直重试</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        old := la.array.get(idx)</span><br><span class="line">        <span class="keyword">if</span> old == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 为空，则初始化</span></span><br><span class="line">            newWrap := &amp;BucketWrap&#123;</span><br><span class="line">                BucketStart: bucketStart,</span><br><span class="line">                Value:       atomic.Value&#123;&#125;,</span><br><span class="line">            &#125;</span><br><span class="line">            newWrap.Value.Store(bg.NewEmptyBucket())</span><br><span class="line">            <span class="keyword">if</span> la.array.compareAndSet(idx, <span class="literal">nil</span>, newWrap) &#123;</span><br><span class="line">                <span class="keyword">return</span> newWrap, <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                runtime.Gosched() <span class="comment">// 被其他协程抢占了，放弃重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> bucketStart == atomic.LoadUint64(&amp;old.BucketStart) &#123;</span><br><span class="line">            <span class="comment">// bucket中的起始时间戳正确，直接使用。</span></span><br><span class="line">            <span class="keyword">return</span> old, <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> bucketStart &gt; atomic.LoadUint64(&amp;old.BucketStart) &#123; <span class="comment">// bucket已过期，进入新一轮周期了，需要Reset</span></span><br><span class="line">            <span class="keyword">if</span> la.updateLock.TryLock() &#123; <span class="comment">// 抢占锁，为了更新BucketWrap格子</span></span><br><span class="line">                old = bg.ResetBucketTo(old, bucketStart)</span><br><span class="line">                la.updateLock.Unlock()</span><br><span class="line">                <span class="keyword">return</span> old, <span class="literal">nil</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                runtime.Gosched() <span class="comment">// 被其他协程抢占了，放弃重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> bucketStart &lt; atomic.LoadUint64(&amp;old.BucketStart) &#123; <span class="comment">// bucket中的时间还大于当前时间</span></span><br><span class="line">            <span class="keyword">if</span> la.sampleCount == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 只有1个bucket，正常</span></span><br><span class="line">                <span class="keyword">return</span> old, <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 时钟跳变？</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;Provided time timeMillis=%d is already behind old.BucketStart=%d.&quot;</span>, bucketStart, old.BucketStart))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取最近一段周期时间内的bucket列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(la *LeapArray)</span></span> valuesWithTime(now <span class="type">uint64</span>) []*BucketWrap &#123;</span><br><span class="line">    <span class="keyword">if</span> now &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make</span>([]*BucketWrap, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="built_in">make</span>([]*BucketWrap, <span class="number">0</span>, la.array.length)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; la.array.length; i++ &#123;</span><br><span class="line">        ww := la.array.get(i)</span><br><span class="line">        <span class="keyword">if</span> ww == <span class="literal">nil</span> || la.isBucketDeprecated(now, ww) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, ww)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BucketLeapArray</strong>：在LeapArray之上的滑动窗口封装，可以理解为LeapArray的API层。负责将滑动窗口的实现以及Bucket内容generator的实现关联，对外提供一个带数据存储的完整滑动窗口实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BucketLeapArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    data     LeapArray <span class="comment">// 底层使用LeapArray</span></span><br><span class="line">    dataType <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket数据generator，用于bucketWrap初始化时填充数据对象MetricBucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bla *BucketLeapArray)</span></span> NewEmptyBucket() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> NewMetricBucket()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取now对应的数据对象MetricBucket（删除了错误处理代码）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bla *BucketLeapArray)</span></span> currentBucketWithTime(now <span class="type">uint64</span>) *MetricBucket &#123;</span><br><span class="line">    curBucket, err := bla.data.currentBucketOfTime(now, bla) <span class="comment">// 定位bucket</span></span><br><span class="line">    mb := curBucket.Value.Load() <span class="comment">// 原子操作，取出数据</span></span><br><span class="line">    b, ok := mb.(*MetricBucket)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MetricBucket</strong>：存储在bucket中的统计结构体，格式为分事件存储的数据累加值，以及两个仅需记录最大、最小的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// There are five events to record</span></span><br><span class="line"><span class="comment">// pass + block == Total</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// sentinel rules check pass</span></span><br><span class="line">    MetricEventPass MetricEvent = <span class="literal">iota</span></span><br><span class="line">    <span class="comment">// sentinel rules check block</span></span><br><span class="line">    MetricEventBlock</span><br><span class="line"></span><br><span class="line">    MetricEventComplete</span><br><span class="line">    <span class="comment">// Biz error, used for circuit breaker</span></span><br><span class="line">    MetricEventError</span><br><span class="line">    <span class="comment">// request execute rt, unit is millisecond</span></span><br><span class="line">    MetricEventRt</span><br><span class="line">    <span class="comment">// hack for the number of event</span></span><br><span class="line">    MetricEventTotal</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MetricBucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Value of statistic</span></span><br><span class="line">    counter        [base.MetricEventTotal]<span class="type">int64</span></span><br><span class="line">    minRt          <span class="type">int64</span></span><br><span class="line">    maxConcurrency <span class="type">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见同一资源各种功能的数据是存储在一起的，包括流量控制、并发隔离等。</p>
<p>上层可以直接使用BucketLeapArray来统计数据，但是计算会比较繁琐，所以继续封装了一层<strong>SlidingWindowMetric</strong>对象，来实现周期内的minRT、maxConcurrency等的读取操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SlidingWindowMetric <span class="keyword">struct</span> &#123;</span><br><span class="line">    bucketLengthInMs <span class="type">uint32</span>           <span class="comment">// SlidingWindow的单个长度，单位ms</span></span><br><span class="line">    sampleCount      <span class="type">uint32</span>           <span class="comment">// SlidingWindow的个数</span></span><br><span class="line">    intervalInMs     <span class="type">uint32</span>           <span class="comment">// SlidingWindow的总长度，单位ms</span></span><br><span class="line">    <span class="built_in">real</span>             *BucketLeapArray <span class="comment">// 真实的滑动窗口，SlidingWindow只是上面的聚合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BaseStatNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    sampleCount <span class="type">uint32</span></span><br><span class="line">    intervalMs  <span class="type">uint32</span></span><br><span class="line"></span><br><span class="line">    concurrency <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">    arr    *sbase.BucketLeapArray <span class="comment">// 实际的滑动窗口</span></span><br><span class="line">    metric *sbase.SlidingWindowMetric <span class="comment">// 用于读取的SlidingWindow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaseStatNode</span><span class="params">(sampleCount <span class="type">uint32</span>, intervalInMs <span class="type">uint32</span>)</span></span> *BaseStatNode &#123;</span><br><span class="line">    la := sbase.NewBucketLeapArray(config.GlobalStatisticSampleCountTotal(), config.GlobalStatisticIntervalMsTotal())</span><br><span class="line">    metric, _ := sbase.NewSlidingWindowMetric(sampleCount, intervalInMs, la)</span><br><span class="line">    <span class="keyword">return</span> &amp;BaseStatNode&#123;</span><br><span class="line">        concurrency: <span class="number">0</span>,</span><br><span class="line">        sampleCount: sampleCount,</span><br><span class="line">        intervalMs:  intervalInMs,</span><br><span class="line">        arr:         la,</span><br><span class="line">        metric:      metric,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是SlidingWindow是一个虚拟结构，内部关联了滑动窗口对象，SlidingWindow只可读，而且读的数据是通过聚合各个bucket节点数据得到的。</p>
<p><strong>资源全局滑动窗口</strong></p>
<p>规则根据滑动窗口使用方式上，存在两种类型的滑动窗口：</p>
<ol>
<li>规则自己的滑动窗口，由该规则独享。其长度以及bucket数目由规则的StatIntervalInMs参数以及计算出来sampleCount参数决定。</li>
<li>资源下的共享滑动窗口，其长度以及bucket数目由全局配置globalStatisticSampleCountTotal<strong>、</strong>globalStatisticIntervalMsTotal参数决定。</li>
</ol>
<p>理论上每条Rule维护自己的时间窗是最为简单的，这样可以保持数据之间相互隔离。但是维持时间窗一个比较重的逻辑，需要维持计数的准确性。如果存在10条规则，那么每个规则的时间窗都需要进行对应的bucket计数加1操作。于是出现了资源下的共享滑动窗口（也叫全局滑动窗口）的概念。</p>
<p><strong>数据统计结构standaloneStatistic</strong>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> standaloneStatistic <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Rule是否复用了resource的统计结构</span></span><br><span class="line">    reuseResourceStat <span class="type">bool</span></span><br><span class="line">    <span class="comment">// readOnlyMetric is the readonly metric statistic.</span></span><br><span class="line">    <span class="comment">// if reuseResourceStat is true, it would be the reused SlidingWindowMetric</span></span><br><span class="line">    <span class="comment">// if reuseResourceStat is false, it would be the BucketLeapArray</span></span><br><span class="line">  <span class="comment">// 只读的</span></span><br><span class="line">    readOnlyMetric base.ReadStat</span><br><span class="line">    <span class="comment">// writeOnlyMetric is the write only metric statistic.</span></span><br><span class="line">    <span class="comment">// if reuseResourceStat is true, it would be nil</span></span><br><span class="line">    <span class="comment">// if reuseResourceStat is false, it would be the BucketLeapArray</span></span><br><span class="line">    writeOnlyMetric base.WriteStat</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="资源访问"><a href="#资源访问" class="headerlink" title="资源访问"></a>资源访问</h3><p>入口：Entry</p>
<p>使用责任链模式，完成各种功能的check。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sentinel 本质是一个流控包，不仅提供了限流功能，还提供了众多其他诸如自适应流量保护、熔断降级、冷启动、全局流量 Metrics 结果等功能流控组件，</span></span><br><span class="line"><span class="comment">// Sentinel-Go 包定义了一个 SlotChain 实体存储其所有的流控组件。</span></span><br><span class="line"><span class="keyword">type</span> SlotChain <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// statPres is in ascending order by StatPrepareSlot.Order() value.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// - ResourceNodePrepareSlot(): 确保已经有resouce对应的ResouceNode节点了。即ctx.StatNode</span></span><br><span class="line">    statPres []StatPrepareSlot</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各种控制类型校验：</span></span><br><span class="line">    <span class="comment">// - system.DefaultAdaptiveSlot： 系统自适应保护检验，见https://sentinelguard.io/zh-cn/docs/golang/system-adaptive-protection.html</span></span><br><span class="line">    <span class="comment">// - flow.DefaultSlot：流控校验</span></span><br><span class="line">    <span class="comment">// - isolation.DefaultSlot：并发隔离控制校验，见https://sentinelguard.io/zh-cn/docs/golang/concurrency-limiting-isolation.html</span></span><br><span class="line">    <span class="comment">// - hotspot.DefaultSlot：热点资源流控，见https://sentinelguard.io/zh-cn/docs/golang/hotspot-param-flow-control.html</span></span><br><span class="line">    <span class="comment">// - circuitbreaker.DefaultSlot：熔断降级，见 https://sentinelguard.io/zh-cn/docs/golang/circuit-breaking.html</span></span><br><span class="line">    ruleChecks []RuleCheckSlot</span><br><span class="line">    <span class="comment">// stats is in ascending order by StatSlot.Order() value.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各种统计类型：对block和非block分别统计</span></span><br><span class="line">    <span class="comment">// - stat.DefaultSlot: （出入）流量统计，包括Prometheus上报</span></span><br><span class="line">    <span class="comment">// - log.DefaultSlot)：nil</span></span><br><span class="line">    <span class="comment">// - flow.DefaultStandaloneStatSlot)：写流量统计的MetricEventPass事件数据</span></span><br><span class="line">    <span class="comment">// - hotspot.DefaultConcurrencyStatSlot)：写并发隔离控制的concurrency数据，pass +1，blocked -1</span></span><br><span class="line">    <span class="comment">// - circuitbreaker.DefaultMetricStatSlot)：熔断降级处理，nil</span></span><br><span class="line">    stats []StatSlot</span><br><span class="line">    <span class="comment">// EntryContext Pool, used for reuse EntryContext object</span></span><br><span class="line">    ctxPool *sync.Pool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry: sentinel所有检查功能入口，将各种数据Prepare、功能检查以及统计上报逻辑都轮轮询一遍。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *SlotChain)</span></span> Entry(ctx *EntryContext) *TokenResult &#123;</span><br><span class="line">  <span class="comment">// ... 删除部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据准备slots</span></span><br><span class="line">    sps := sc.statPres</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sps) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> sps &#123;</span><br><span class="line">            s.Prepare(ctx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阈值校验slots</span></span><br><span class="line">    rcs := sc.ruleChecks</span><br><span class="line">    <span class="keyword">var</span> ruleCheckRet *TokenResult</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(rcs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> rcs &#123;</span><br><span class="line">            sr := s.Check(ctx)</span><br><span class="line">            <span class="keyword">if</span> sr == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// nil equals to check pass</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 某个规则block，则跳过后续检查</span></span><br><span class="line">            <span class="keyword">if</span> sr.IsBlocked() &#123;</span><br><span class="line">                ruleCheckRet = sr</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据统计slots</span></span><br><span class="line">    ss := sc.stats</span><br><span class="line">    ruleCheckRet = ctx.RuleCheckResult</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ss) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> ss &#123;</span><br><span class="line">            <span class="comment">// indicate the result of rule based checking slot.</span></span><br><span class="line">            <span class="keyword">if</span> !ruleCheckRet.IsBlocked() &#123;</span><br><span class="line">                s.OnEntryPassed(ctx)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The block error should not be nil.</span></span><br><span class="line">                s.OnEntryBlocked(ctx, ruleCheckRet.blockErr)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ruleCheckRet</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sentinel的功能很丰富，存在各种语言的版本，实现上也非常注意性能相关的细节优化。在一些并发逻辑的处理上也值得学习。如果要将其性能发挥到最大的空间，还需要进一步自信分析各种参数配置，包括滑动窗口的配置、定制SlotChain等。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://www.goroutine.cn">Alex guo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://www.goroutine.cn/2023/11/10/Sentinel-Code-Analyze/">https://www.goroutine.cn/2023/11/10/Sentinel-Code-Analyze/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Governance/">Governance</a><a class="post-meta__tags" href="/tags/Microservices/">Microservices</a></div><div class="post_share"><div class="social-share" data-image="https://cos.goroutine.cn/uPic/20231110-HERXa8-cyZzFk.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/13/Archive-Service-Governance/" title="Archive Service Governance"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">Archive Service Governance</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/24/Introduct-to-dexide-dex/" title="Introduct to dexide / dex"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Introduct to dexide / dex</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/12/04/Application-Tracking/" title="Application Tracking"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-04</div><div class="title">Application Tracking</div></div></a></div><div><a href="/2023/11/13/Archive-Service-Governance/" title="Archive Service Governance"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-13</div><div class="title">Archive Service Governance</div></div></a></div><div><a href="/2022/01/07/Open-Tracing/" title="Open Tracing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-07</div><div class="title">Open Tracing</div></div></a></div><div><a href="/2023/09/18/Introduct-to-go-clean-template/" title="Introduct to go-clean-template"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-18</div><div class="title">Introduct to go-clean-template</div></div></a></div><div><a href="/2022/01/10/Microservices-in-Action/" title="Microservices in Action"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">Microservices in Action</div></div></a></div><div><a href="/2020/06/08/gomicro-config/" title="gomicro-config"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-08</div><div class="title">gomicro-config</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cos.goroutine.cn/uPic/20231110-HERXa8-cyZzFk.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alex guo</div><div class="author-info__description">个人技术博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/alex-guoba"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa fa-rss"></i></a><a class="social-icon" href="https://github.com/alex-guoba" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#sentinel-go"><span class="toc-number">1.</span> <span class="toc-text">sentinel-go</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">熔断降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.3.</span> <span class="toc-text">系统负载保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%A7%84%E5%88%99"><span class="toc-number">1.2.2.</span> <span class="toc-text">配置规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%8B%E7%82%B9%EF%BC%88%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">埋点（资源访问）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%98%B2%E6%8A%A4%E7%9A%84%E5%85%A5%E5%8F%A3%E5%92%8C%E5%87%BA%E5%8F%A3%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">资源防护的入口和出口代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">熔断降级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinel%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.1.</span> <span class="toc-text">sentinel初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%A7%84%E5%88%99%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">流量控制规则初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">流量统计数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE"><span class="toc-number">1.4.4.</span> <span class="toc-text">资源访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/25/Cache-In-Next-js/" title="Cache In Next.js">Cache In Next.js</a><time datetime="2024-03-25T15:22:06.000Z" title="Created 2024-03-25 23:22:06">2024-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/06/Introduct-to-NotionAPI/" title="Introduct to NotionAPI">Introduct to NotionAPI</a><time datetime="2024-01-06T14:26:24.000Z" title="Created 2024-01-06 22:26:24">2024-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/28/Architecture-of-Supabase/" title="Architecture of Supabase">Architecture of Supabase</a><time datetime="2023-12-28T15:05:38.000Z" title="Created 2023-12-28 23:05:38">2023-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/08/Introduct-to-nocoDB/" title="Introduct-to-nocoDB">Introduct-to-nocoDB</a><time datetime="2023-12-08T12:41:25.000Z" title="Created 2023-12-08 20:41:25">2023-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/06/Doploy-outline-without-docker/" title="Doploy outline without docker">Doploy outline without docker</a><time datetime="2023-12-06T08:41:25.000Z" title="Created 2023-12-06 16:41:25">2023-12-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Alex guo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>